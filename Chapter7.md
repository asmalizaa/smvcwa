# Handling Requests

## Identifying Views

Spring MVC defines the ViewResolver and View interfaces that let you render models in a browser without tying you to a specific view technology. ViewResolver provides a mapping between view names and actual views. View addresses the preparation of data before handing over to a specific view technology.

The following table provides more details on the ViewResolver hierarchy:

<table>
  <tr><th>ViewResolver</th><th>Description</th></tr>
  <tr>
    <td>AbstractCachingViewResolver</td>
    <td>Subclasses of AbstractCachingViewResolver cache view instances that they resolve. Caching improves performance of certain view technologies. You can turn off the cache by setting the cache property to false. Furthermore, if you must refresh a certain view at runtime (for example, when a FreeMarker template is modified), you can use the removeFromCache(String viewName, Locale loc) method.</td>
  </tr>
  <tr>
    <td>UrlBasedViewResolver</td>
    <td>Simple implementation of the ViewResolver interface that effects the direct resolution of logical view names to URLs without an explicit mapping definition. This is appropriate if your logical names match the names of your view resources in a straightforward manner, without the need for arbitrary mappings.</td>
  </tr>
  <tr>
    <td>InternalResourceViewResolver</td>
    <td>Convenient subclass of UrlBasedViewResolver that supports InternalResourceView (in effect, Servlets and JSPs) and subclasses such as JstlView. You can specify the view class for all views generated by this resolver by using setViewClass(..). See the UrlBasedViewResolver javadoc for details.</td>
  </tr>
  <tr>
    <td>FreeMarkerViewResolver</td>
    <td>Convenient subclass of UrlBasedViewResolver that supports FreeMarkerView and custom subclasses of them.</td>
  </tr>
  <tr>
    <td>ContentNegotiatingViewResolver</td>
    <td>Implementation of the ViewResolver interface that resolves a view based on the request file name or Accept header.</td>
  </tr>
  <tr>
    <td>BeanNameViewResolver</td>
    <td>Implementation of the ViewResolver interface that interprets a view name as a bean name in the current application context. This is a very flexible variant which allows for mixing and matching different view types based on distinct view names. Each such View can be defined as a bean e.g. in XML or in configuration classes.</td>
  </tr>
</table>

## @RequestMapping

You can use the @RequestMapping annotation to map requests to controllers methods. It has various attributes to match by URL, HTTP method, request parameters, headers, and media types. You can use it at the class level to express shared mappings or at the method level to narrow down to a specific endpoint mapping.

There are also HTTP method specific shortcut variants of @RequestMapping:
- @GetMapping
- @PostMapping
- @PutMapping
- @DeleteMapping
- @PatchMapping

```java
@RestController
@RequestMapping("/persons")
class PersonController {

	@GetMapping("/{id}")
	public Person getPerson(@PathVariable Long id) {
		// ...
	}

	@PostMapping
	@ResponseStatus(HttpStatus.CREATED)
	public void add(@RequestBody Person person) {
		// ...
	}
}
```

## @RequestParam

You can use the @RequestParam annotation to bind Servlet request parameters (that is, query parameters or form data) to a method argument in a controller.

The following example shows how to do so:

```java
@Controller
@RequestMapping("/pets")
public class EditPetForm {

	// ...

	@GetMapping
	public String setupForm(@RequestParam("petId") int petId, Model model) {
		Pet pet = this.clinic.loadPet(petId);
		model.addAttribute("pet", pet);
		return "petForm";
	}

	// ...

}
```
> 	Using @RequestParam to bind petId.

By default, method parameters that use this annotation are required, but you can specify that a method parameter is optional by setting the @RequestParam annotation’s required flag to false or by declaring the argument with an java.util.Optional wrapper.

Type conversion is automatically applied if the target method parameter type is not String.

## Command Object

In Spring Web MVC you can use any object as a command or form-backing object; you do not need to implement a framework-specific interface or base class. 

Spring's data binding is highly flexible: for example, it treats type mismatches as validation errors that can be evaluated by the application, not as system errors. Thus you need not duplicate your business objects' properties as simple, untyped strings in your form objects simply to handle invalid submissions, or to convert the Strings properly. Instead, it is often preferable to bind directly to your business objects.

## Return Types

The following are the supported return types:

- A **ModelAndView** object, with the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
- A **Model** object, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of **@ModelAttribute** annotated reference data accessor methods.
- A **Map** object for exposing a model, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of **@ModelAttribute** annotated reference data accessor methods.
- A **View** object, with the model implicitly determined through command objects and **@ModelAttribute** annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).
- A **String** value that is interpreted as the logical view name, with the model implicitly determined through command objects and **@ModelAttribute** annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).
- **void** if the method handles the response itself (by writing the response content directly, declaring an argument of type **ServletResponse / HttpServletResponse** for that purpose) or if the view name is supposed to be implicitly determined through a **RequestToViewNameTranslator** (not declaring a response argument in the handler method signature).
- If the method is annotated with **@ResponseBody**, the return type is written to the response HTTP body. The return value will be converted to the declared method argument type using **HttpMessageConverters**. 
- A **HttpEntity<?>** or **ResponseEntity<?>** object to provide access to the Servlet response HTTP headers and contents. The entity body will be converted to the response stream using **HttpMessageConverters**. 
- A **Callable<?>** can be returned when the application wants to produce the return value asynchronously in a thread managed by Spring MVC.
- A **DeferredResult<?>** can be returned when the application wants to produce the return value from a thread of its own choosing.
- Any other return type is considered to be a single model attribute to be exposed to the view, using the attribute name specified through **@ModelAttribute** at the method level (or the default attribute name based on the return type class name). The model is implicitly enriched with command objects and the results of **@ModelAttribute** annotated reference data accessor methods.

## Path Variables

The @PathVariable annotation can be used to handle template variables in the request URI mapping, and set them as method parameters.

A simple use case of the @PathVariable annotation would be an endpoint that identifies an entity with a primary key.

```java
@GetMapping("/api/employees/{id}")
@ResponseBody
public String getEmployeesById(@PathVariable String id) {
    return "ID: " + id;
}
```

In this example, we use the @PathVariable annotation to extract the templated part of the URI, represented by the variable {id}.

A simple GET request to /api/employees/{id} will invoke getEmployeesById with the extracted id value:

```
http://localhost:8080/api/employees/111 
---- 
ID: 111
```

## HTTP Headers

Let's look at how to access HTTP Headers in a Spring Rest Controller. 
- First, we’ll be using the @RequestHeader annotation to read headers individually as well as all together.
- After that, we’ll take a deeper look at the @RequestHeader attributes.

If we need access to a specific header, we can configure @RequestHeader with the header name:

```java
@GetMapping("/greeting")
public ResponseEntity<String> greeting(@RequestHeader(HttpHeaders.ACCEPT_LANGUAGE) String language) {
    // code that uses the language variable
    return new ResponseEntity<String>("Hello there!", HttpStatus.OK);
}
```

Then we can access the value using the variable passed into our method. If a header named accept-language isn’t found in the request, the method returns a "400 Bad Request" error.

Our headers don’t have to be strings. If we know our header is a number, we can declare our variable as a numeric type:

```java
@GetMapping("/double")
public ResponseEntity<String> doubleNumber(@RequestHeader("my-number") int myNumber) {
    return new ResponseEntity<String>(String.format("%d * 2 = %d", 
      myNumber, (myNumber * 2)), HttpStatus.OK);
}
```

To test, add these codes to any controller you've created before eg. HelloController, run and test it using Postman.

## Cookies

Cookies are the concept of storing user information on the client side in the form of a text file. In this text file lot of information is available about clients or users. 

Cookies are small pieces of data that are sent by the web servers to the user’s web browsers and those cookies are stored in the client only, the cookies play an important role in web development for tracking the user’s activities while using the website. Mostly the cookies are used in Authentication Tokens, Privacy, Session Handling, Tracking, and Analytics of user activity. 

Cookies are again categorized into two types of Server-Side Cookies and Client-Side Cookies. Here, we discuss about @CookieValue Annotation in Spring MVC.

In Cookies, some components are available those are:
-  Name-Value Pair: The Cookies consist of a name and value pair, which means the name is the identifier and the value is the data associated with that identifier.
-  Domain: It specifies the domain to which, the cookie belongs, and cookies are sent to a domain for every request.
-  Path: It defines the Scope of the Cookie.
-  Expiration Date: It defines When the cookies are expired. After this cookie expiration automatically, the cookie is deleted by the Browser.
-  Secure Flag: If we set this to cookie. Then Cookies are sent only over HTTPS Connections.
-  HttpOnly Flag: If we set this to Cookie, then those cookies are not accessible from Client-Side Scripts.

### @CookieValue Annotation

In Spring MVC, @CookieValue, this annotation provides a convenient way for working with cookies in controller method. And @CookieValue provides a easy way for extracting cookie values and integrate them into out application. @CookieValue is used in spring MVC for binding method parameters value of a HTTP cookie.

**Note: To continue with next examples, create a new project using Spring Initializr and make sure to include dependencies: Spring Web and Thymeleaf**

```java
package com.example.cookiesdemo;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@RequestMapping("/cookies")
public class CookieController {

	@RequestMapping("/readCookie")
	@ResponseBody
	public String readCookieValue(
			@CookieValue(value = "cookieName", defaultValue = "defaultCookieValue") String cookieValue) {
		// Your logic here using the cookie value
		return "Cookie Value: " + cookieValue;
	}
}
```

### Example of @CookieValue Annotation

Reference: (https://www.geeksforgeeks.org/working-with-cookies-in-spring-mvc-using-cookievalue-annotation/)

Now we will see the working functionality of @CookieValue in Spring MVC with simple user signup form.

Steps
1. Create new project (if only)
2. Create a user model
3. Create the controller
4. Create the view (HTML page)
5. Run and test

**User.java**

```java
package com.example.cookiesdemo;

public class User {

	private String username;
	private String email;

	public User() {

	}

	public User(String username, String email) {
		this.username = username;
		this.email = email;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}
}
```

**UserController.java***

```java
package com.example.cookiesdemo;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;

@Controller
@RequestMapping("/user")
public class UserController {

	@GetMapping("/register")
	public String showRegistrationForm(Model model) {
		model.addAttribute("user", new User());
		return "index";
	}

	@PostMapping("/register")
	public String registerUser(User user, HttpServletResponse response) {
		// For simplicity, we'll just set a cookie with the username
		Cookie cookie = new Cookie("usernameCookie", user.getUsername());
		response.addCookie(cookie);
		return "redirect:/user/welcome";
	}

	@GetMapping("/welcome")
	@ResponseBody
	public String welcomeUser(@CookieValue(value = "usernameCookie", defaultValue = "Guest") String username) {
		return "Welcome, " + username + "!";
	}
}
```

In above code, we have used different annotations for different purposes. @Controller Annotation is used for creating a controller layer. And It indicates that particular class serve as a role of controller. After that we have used @RequestMapping Annotation for to map web requests for a specific handler class, And the @RequestMapping annotation is used with @Controller. @RequestMapping It is applied for both class and it’s methods. After that we have used @GetMapping for mapping HTTP Get Requests for a Specific handler class.

- @GetMapping(“/register”) this is used for display the HTML Page on the web browser using Model.
- @PostMapping(“/register”) It is used for submitting the data through the HTML Form.
- @GetMapping(“/welcome”) is used for Displaying the Cookie Value on the web browser.

**index.html**

```html
<!DOCTYPE html> 
<html lang="en" xmlns:th="http://www.thymeleaf.org"> 
<head> 
	<meta charset="UTF-8"> 
	<meta name="viewport" content="width=device-width, initial-scale=1.0"> 
	<title>User Registration</title> 

	<!-- Include Bootstrap CSS -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
		integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm"
		crossorigin="anonymous"> 
</head> 
<body> 

<div class="container mt-5"> 
	<form th:action="@{/user/register}" th:object="${user}" method="post" class="col-md-6 offset-md-3"> 
		<h2 class="mb-4">User Registration</h2> 

		<div class="form-group"> 
			<label for="username">Username:</label> 
			<input type="text" id="username" th:field="*{username}" class="form-control" required> 
		</div> 

		<div class="form-group"> 
			<label for="email">Email:</label> 
			<input type="email" id="email" th:field="*{email}" class="form-control" required> 
		</div> 

		<button type="submit" class="btn btn-success">Register</button> 
	</form> 
</div> 

<!-- Include Bootstrap JS and Popper.js -->
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
		integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
		crossorigin="anonymous"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
		integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q"
		crossorigin="anonymous"></script> 
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
		integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl"
		crossorigin="anonymous"></script> 

</body> 
</html> 
```

Run the application, in the browser type (http://localhost:8080/user/register)

![image](https://github.com/asmalizaa/smvcwa/assets/23090837/d933dd71-b43a-4931-bf8c-e422c2f42e13)

After submitting the form.

![image](https://github.com/asmalizaa/smvcwa/assets/23090837/e89d5e19-2dfe-41d1-8e85-363b21484c8b)


